package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  public Absyn.Exp parseResult;
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, 
			   java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, 
	LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
	TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
	ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO, DO, 
	LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal Program program;
non terminal Absyn.Exp exp;
non terminal Absyn.ExpList expList;
non terminal Absyn.ExpList expListAux;
non terminal Absyn.Exp letExp;
non terminal Absyn.DecList decList;
non terminal Absyn.Dec dec;
non terminal Absyn.VarDec varDec;
non terminal funcDec, typeId;
non terminal Absyn.TypeDec tyDec;
non terminal Absyn.Ty ty;
non terminal Absyn.ArrayTy arrTy;
non terminal Absyn.RecordTy recTy;
non terminal Absyn.FieldList fieldDec, fieldDecList, fieldDecListAux;
non terminal Absyn.RecordExp recCreate;
non terminal Absyn.AssignExp assignment;
non terminal Absyn.FieldExpList fieldCreate;
non terminal Absyn.FieldExpList fieldCreateList;
non terminal Absyn.FieldExpList fieldCreateListAux;
non terminal Absyn.Var lValue;
non terminal arrCreate, subscript;
non terminal Absyn.FieldVar fieldExp;
non terminal infixExp;
non terminal Absyn.ExpList seqExp, seqExpAux; 
non terminal callExp, ifThen, ifThenElse, whileExp, forExp, negation; 

precedence left TIMES, DIVIDE;
precedence left PLUS, MINUS;
precedence left EQ, NEQ;
precedence left GT, LT;
precedence left GE, LE;
precedence left AND, OR;

start with program;

program ::= exp:e {: RESULT = new Program(e); :};

dec ::= varDec:vd {: RESULT = vd; :}
| tyDec:td {: RESULT = td; :}
| funcDec;

tyDec ::= TYPE ID:i EQ ty:t {: RESULT = new Absyn.TypeDec(ileft, Symbol.Symbol.symbol(i), t, null); :};

ty ::= ID:i {: RESULT = new Absyn.NameTy(ileft, Symbol.Symbol.symbol(i)); :}
| recTy:rt {: RESULT = rt; :}
| arrTy:ar {: RESULT = ar; :};

arrTy ::= ARRAY OF ID:i {: RESULT = new Absyn.ArrayTy(ileft, Symbol.Symbol.symbol(i)); :};

recTy ::= LBRACE fieldDecList:fl RBRACE {:  RESULT = new Absyn.RecordTy(flleft, fl); :};

fieldDecList ::= fieldDec:fd fieldDecListAux:fdla {: RESULT = new Absyn.FieldList(fdleft, fd.name, fd.typ, fdla); :}
| /* empty */ ;

fieldDecListAux ::= COMMA fieldDec:fd fieldDecListAux:fdla {: RESULT = new Absyn.FieldList(fdleft, fd.name, fd.typ, fdla); :}
| /* empty */;

fieldDec ::= ID:i COLON ID:ty {: RESULT = new Absyn.FieldList(ileft, Symbol.Symbol.symbol(i), Symbol.Symbol.symbol(ty), null); :};

funcDec ::= FUNCTION ID LPAREN fieldDecList RPAREN EQ exp
| FUNCTION ID LPAREN fieldDecList RPAREN COLON ID EQ exp;

varDec ::= VAR ID:i ASSIGN exp:e {: RESULT = new Absyn.VarDec(ileft, Symbol.Symbol.symbol(i), null, e); :}
| VAR ID:i COLON ty:t ASSIGN exp:e {: RESULT = new Absyn.VarDec(ileft, Symbol.Symbol.symbol(i), (Absyn.NameTy)t, e); :}
;


lValue ::= ID:id  {: RESULT = new Absyn.SimpleVar(idleft, Symbol.Symbol.symbol(id)); :}
| subscript
| fieldExp:fe {: RESULT = fe; :};


subscript ::= lValue LBRACK exp RBRACK; //NOT SURE ABOUT THIS you could have a subscript of a subscript etc....

fieldExp ::= lValue:lv DOT ID:i {: RESULT = new Absyn.FieldVar(lvleft, lv, Symbol.Symbol.symbol(i)); :};

exp ::= lValue:lv {: RESULT = new Absyn.VarExp(lvleft, lv); :}
| NIL:n {: RESULT = new Absyn.NilExp(nleft); :} 
| INT:i {: RESULT = new Absyn.IntExp(ileft, i); :}
| STRING:s {: RESULT = new Absyn.StringExp(sleft, s); :} 
| seqExp:se {: RESULT = new Absyn.SeqExp(seleft, se); :}
| callExp 
| infixExp
| arrCreate
| recCreate:rc {: RESULT = rc; :}
| assignment:a {: RESULT = a; :}
| negation 
| ifThenElse
| ifThen
| whileExp 
| forExp 
| BREAK:b {: RESULT = new Absyn.BreakExp(bleft); :}
| letExp:le {: RESULT = le; :}
;

negation ::= MINUS exp;

infixExp ::= exp PLUS exp
| exp MINUS exp
| exp TIMES exp
| exp DIVIDE exp
| exp EQ exp
| exp NEQ exp
| exp GT exp
| exp LT exp
| exp GE exp
| exp LE exp
| exp AND exp
| exp OR exp
;

seqExp ::= LPAREN RPAREN
| LPAREN exp:e seqExpAux:sea RPAREN {: RESULT = new Absyn.ExpList(e, sea); :};

seqExpAux ::= SEMICOLON exp:e seqExpAux:sea {: RESULT = new Absyn.ExpList(e, sea); :}
| /* empty */;

callExp ::= ID LPAREN expList RPAREN;

expList ::= exp:e expListAux:a {: RESULT = new Absyn.ExpList(e, a); :}
| /* empty */;

expListAux ::= SEMICOLON exp:e expListAux:a {: RESULT = new Absyn.ExpList(e, a); :}
| /* empty */;

assignment ::= lValue:l ASSIGN exp:e {: RESULT = new Absyn.AssignExp(lleft, l, e); :};

ifThen ::= IF exp THEN exp;

ifThenElse ::= IF exp THEN exp ELSE exp;

whileExp ::= WHILE exp:e1 DO exp:e2 {: RESULT = new Absyn.WhileExp(e1left, (Absyn.Exp)e1, (Absyn.Exp)e2); :};

forExp ::= FOR ID ASSIGN exp TO exp DO exp;

letExp ::= LET decList:e1 IN exp:e2 END {: RESULT = new Absyn.LetExp(e1left, (Absyn.DecList)e1, (Absyn.Exp)e2); :};

decList ::= dec:d decList:dl {: RESULT = new Absyn.DecList(d, dl); :} 
| /* empty */ ;

typeId ::= ID:i; //extra rule added to correct conflict between arrCreate and lValue

//arrCreate ::= subscript OF exp; //POSSIBLY WRONG
arrCreate ::= typeId OF exp; 

recCreate ::= ID:i LBRACE fieldCreateList:fcl RBRACE {: RESULT = new Absyn.RecordExp(ileft, Symbol.Symbol.symbol(i), fcl); :};

fieldCreateList ::= fieldCreate:fc fieldCreateListAux:fcla {: RESULT = new Absyn.FieldExpList(fcleft, fc.name, fc.init, fcla); :}
| /* empty */;

fieldCreateListAux ::= COMMA fieldCreate:fc fieldCreateListAux:fcla {: RESULT = new Absyn.FieldExpList(fcleft, fc.name, fc.init, fcla); :}
| /* empty */;

fieldCreate ::= ID:i EQ exp:e {: RESULT = new Absyn.FieldExpList(ileft, Symbol.Symbol.symbol(i), e, null); :};