package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  //public Absyn.Exp parseResult;
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, 
			   java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, 
	LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
	TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
	ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO, DO, 
	LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal program, exp, expList, letExp, decList, dec, tyDec, funcDec;
non terminal ty, tyField, tyFieldList, tyFieldListAux, varDecList, varDec;
non terminal lValue, iFieldList, iFieldListAux, iField, iRec, assignExp;
non terminal lValueAux;
start with program;

program ::= expList
;
expList ::= exp expList
| /* empty */
;
exp ::= letExp
| STRING
| INT
| iRec
| lValue
;

assignExp ::= lValue ASSIGN expList
;

letExp ::= LET decList IN expList END
;

decList ::= dec decList 
| /* empty */
;
dec ::= varDec | tyDec
;
varDec ::= VAR ID ASSIGN exp
| VAR ID COLON ty ASSIGN exp
;

tyDec ::= TYPE ID EQ ty
;
ty ::= ID
| LBRACE tyFieldList RBRACE
| ARRAY OF ID
;
tyFieldList ::= tyField tyFieldListAux
| /* empty */
;
tyFieldListAux ::= COMMA tyField tyFieldListAux
| /* empty */
;
tyField ::= ID COLON ty
;

lValue ::= ID:id lValueAux
;
lValueAux ::= DOT ID:id
| LBRACK expList:e RBRACK
|
;

iRec ::= ty LBRACE iFieldList RBRACE
;
iFieldList ::= iField iFieldListAux
| /* empty */
;
iFieldListAux ::= COMMA iField iFieldListAux 
| /* empty */
;
iField ::= ID EQ exp
;