package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  //public Absyn.Exp parseResult;
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, 
			   java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, 
	LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
	TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
	ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO, DO, 
	LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal program, exp, expList, letExp, decList, dec, tyDec, funcDec;
non terminal ty, tyField, tyFieldList, varDecList, varDec;
non terminal lValue, iFieldList, iField, iRec;
start with program;

program ::= expList
;
expList ::= exp expList
| /* empty */
;
exp ::= letExp
| lValue
| iRec
| STRING
;
letExp ::= LET decList IN expList END
;

decList ::= decList dec
| /* empty */
;
dec ::= varDec | tyDec
;
varDec ::= VAR ID ASSIGN exp
| VAR ID COLON ty ASSIGN exp
;

tyDec ::= TYPE ID EQ ty
;
ty ::= ID
| INT
| STRING
| LBRACE tyFieldList RBRACE
| ARRAY OF ID
;
tyFieldList ::= tyFieldList COMMA tyField
| tyField
| /* empty */
;
tyField ::= ID COLON ty
;

lValue ::= ID:v1
| lValue DOT ID:v1
| lValue LBRACK expList RBRACK
;

iRec ::= ty LBRACE iFieldList RBRACE
;
iFieldList ::= iField COMMA iFieldList 
| iField
;
iField ::= ID EQ exp
;