package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  //public Absyn.Exp parseResult;
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, 
			   java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, 
	LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
	TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
	ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO, DO, 
	LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal program, exp, letexp, stmtlist, stmt, declist, dec, var_dec, type_dec, func_dec;

start with program;

program ::= exp;

exp ::= letexp
| stmtlist
;

letexp ::= LET declist IN stmtlist END
| /* empty */
;

stmtlist ::= stmtlist stmt:s {: System.out.println(">>> stmtlist:" + s); :}
| /* empty */
;

declist ::= declist dec:d {: System.out.println(">>> declist " + d); :}
| /* empty */
;

var_dec ::=  VAR ID:lhs_var COLON ID:lhs_type ASSIGN ID:rhs_type LBRACK INT:rank RBRACK OF INT:rank1 {: System.out.println(">>> var_dec"); :}
;

type_dec ::= TYPE ID:v1 EQ ARRAY OF INT {: System.out.println(">>> type_dec"); :}
| TYPE ID:v1 EQ INT
| TYPE ID:v1 EQ ARRAY OF ID:v2
| TYPE ID:v1 EQ LBRACE ID:v2 COLON STRING COMMA ID:v3 COLON INT RBRACE
;

dec ::= var_dec | type_dec
;

stmt ::= ID:v1 {: System.out.println(">>> stmt " + v1); :}
;