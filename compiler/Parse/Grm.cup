package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  //public Absyn.Exp parseResult;
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, 
			   java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, 
	LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
	TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
	ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO, DO, 
	LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal program, exp, letexp, stmtlist, stmt, declist, dec, var_dec, type_dec, func_dec;
non terminal typ, type_fields, type_field;
start with program;

program ::= exp;

exp ::= letexp
| stmtlist
;

letexp ::= LET declist IN stmtlist END {: System.out.println("let"); :}
| /* empty */
;

stmtlist ::= stmtlist stmt:s {: System.out.println(">>> stmtlist:" + s); :}
| /* empty */
;

declist ::= declist dec:d {: System.out.println(">>> declist " + d); :}
| /* empty */
;

var_dec ::=  VAR ID:lhs_var COLON ID:lhs_type ASSIGN ID:rhs_type LBRACK INT:rank RBRACK OF INT:rank1 {: System.out.println(">>> var_dec"); :}
;
 
typ ::= ID:v2
| INT {: System.out.println("type INT"); :}
| STRING
| LBRACE type_fields RBRACE
| ARRAY OF ID:v2 {: System.out.println("typ array of " + v2); :}
;

type_fields ::= type_fields COMMA type_field
| /* empty */
;

type_field ::= ID:v2 COLON ID:v3 {: System.out.println("type field " + v2 + " " + v3); :}
;

type_dec ::= TYPE ID:v1 EQ typ {: System.out.println("type_dec " + v1); :}
;

dec ::= var_dec | type_dec
;

stmt ::= ID:v1 {: System.out.println(">>> stmt " + v1); :}
;