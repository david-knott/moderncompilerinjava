package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  public Absyn.Exp parseResult;
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, 
			   java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, 
	LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
	TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
	ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO, DO, 
	LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal Program program;
non terminal Absyn.Exp exp;
non terminal expList, expListAux, letExp, decList, dec, tyDec, funcDec;
non terminal ty, fieldDec, fieldDecList, fieldDecListAux, varDec;
non terminal lValue, fieldCreateList, fieldCreateListAux, fieldCreate, recCreate, assignment;
non terminal arrTy, recTy, arrCreate, subscript, fieldExp, infixExp, seqExp, seqExpAux;
non terminal callExp, ifThen, ifThenElse, whileExp, forExp, negation; 

precedence left TIMES, DIVIDE;
precedence left PLUS, MINUS;
precedence left EQ, NEQ;
precedence left GT, LT;
precedence left GE, LE;
precedence left AND, OR;

start with program;

program ::= exp:e {: RESULT = new Program(e); :};

dec ::= varDec 
| tyDec
| funcDec;

tyDec ::= TYPE ID EQ ty;

ty ::= ID
| recTy
| arrTy;

arrTy ::= ARRAY OF ID;

recTy ::= LBRACE fieldDecList RBRACE;

fieldDecList ::= fieldDec fieldDecListAux
| /* empty */ ;

fieldDecListAux ::= COMMA fieldDec fieldDecListAux
| /* empty */;

fieldDec ::= ID COLON ty;

funcDec ::= FUNCTION ID LPAREN fieldDecList RPAREN EQ exp
| FUNCTION ID LPAREN fieldDecList RPAREN COLON ID EQ exp;

varDec ::= VAR ID ASSIGN exp
| VAR ID COLON ty ASSIGN exp;

lValue ::= ID:id 
| subscript
| fieldExp;

subscript ::= lValue LBRACK exp RBRACK; //NOT SURE ABOUT THIS you could have a subscript of a subscript etc....

fieldExp ::= lValue DOT ID;

exp ::= lValue
| NIL:n {: RESULT = new Absyn.NilExp(nleft); :} 
| INT:i {: RESULT = new Absyn.IntExp(ileft, i); :}
| STRING:s {: RESULT = new Absyn.StringExp(sleft, s); :} 
| seqExp
| callExp 
| infixExp
| arrCreate
| recCreate
| assignment
| negation 
| ifThenElse
| ifThen
| whileExp 
| forExp 
| BREAK {: RESULT = new Absyn.BreakExp(0):}
| letExp
;

negation ::= MINUS exp;

infixExp ::= exp PLUS exp
| exp MINUS exp
| exp TIMES exp
| exp DIVIDE exp
| exp EQ exp
| exp NEQ exp
| exp GT exp
| exp LT exp
| exp GE exp
| exp LE exp
| exp AND exp
| exp OR exp
;

seqExp ::= LPAREN RPAREN
| LPAREN exp seqExpAux RPAREN;

seqExpAux ::= SEMICOLON exp seqExpAux
| /* empty */;

callExp ::= ID LPAREN expList RPAREN;

expList ::= exp expListAux
| /* empty */;

expListAux ::= SEMICOLON exp expListAux
| /* empty */;

assignment ::= lValue ASSIGN exp;

ifThen ::= IF exp THEN exp;

ifThenElse ::= IF exp THEN exp ELSE exp;

whileExp ::= WHILE exp:e1 DO exp:e2 {: RESULT = new Absyn.WhileExp(0, (Absyn.Exp)e1, (Absyn.Exp)e2); :};

forExp ::= FOR ID ASSIGN exp TO exp DO exp;

letExp ::= LET decList:e1 IN expList:e2 END {: RESULT = new Absyn.LetExp(0, (Absyn.DecList)e1, (Absyn.Exp)e2); :};

decList ::= dec decList 
| /* empty */;

arrCreate ::= subscript OF exp; //POSSIBLY WRONG

recCreate ::= ID LBRACE fieldCreateList RBRACE;

fieldCreateList ::= fieldCreate fieldCreateListAux
| /* empty */;

fieldCreateListAux ::= COMMA fieldCreate fieldCreateListAux 
| /* empty */;

fieldCreate ::= ID EQ exp;