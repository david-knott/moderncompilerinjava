// https://web.stanford.edu/class/archive/cs/cs107/cs107.1194/guide/x86-64.html
/**
* Rules that match tiles that load memory address contents into temporoary.
*/

/* Indirect addressing without displacement */
move = MOVE(exp arg0, MEM(exp arg1)) : 10
{
	//System.out.println("movq %" + arg0 + ", (%" + arg1 + ") # mv(t, mm(e))");
	emitter.loadIndirect(arg0, arg1);
	return null;
}

/* indirect addressing with displacement */
move = MOVE(exp arg0, MEM(BINOP(exp arg1, CONST(void) arg2))) : 1
{
	int offset = ((Tree.CONST)arg2).value;
    Tree.BINOP binop = (Tree.BINOP)(__p.getNthChild(1).getNthChild(0));
	Util.Assert.assertIsTrue(binop.binop == Tree.BINOP.PLUS || binop.binop == Tree.BINOP.MINUS);
	emitter.loadIndirectDisp(binop.binop, arg0, arg1, offset);
	return null;
}

/* indirect addressing with displacement and scaled index */
arrayIndex =  MEM(BINOP(exp arg0, BINOP(exp arg1, CONST(void) arg2))) : 1
{
	emitter.startLoadIndirectDispScaled(arg0, arg1, arg2);
	return null;
}

move = MOVE(exp arg0, arrayIndex arg1) : 1
{
	emitter.endLoadIndirectDispScaled(arg0, arg1);
	return null;
}


/*
move = MOVE(exp arg0, MEM(BINOP(TEMP(void) arg1, BINOP(TEMP(void) arg2, CONST(void) arg3)))) : 1
{

	System.out.println("# LLOOK mv(t, mm(b(t b(t, c))))");
	return null;
}
*/

/*
move = MOVE(TEMP(void) arg0, MEM(BINOP(void) arg1, BINOP(TEMP(void) arg2, CONST(void) arg3)))) : 1
{

	System.out.println("# LLOOK mv(t, mm(b(t b(t, c))))");
	return null;
}
*/