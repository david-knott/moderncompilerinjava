package jburg.burg;

//  BURM specification is parsed into ANTLR2 AST objects.
import antlr.collections.AST;
//  The code emitter interface definition.
import jburg.emitter.EmitLang;
// The code emitter works by string templates.
import org.antlr.stringtemplate.*;

//  The factory that selects and creates an emitter.
import jburg.emitter.JBurgEmitterFactory;

//  The i-node adapter interface definition.
import jburg.burg.inode.InodeAdapter;

//  Intermediate representation classes.
import jburg.burg.ir.*;

//  The factory that selects and creates an I-node adapter.
import jburg.burg.inode.InodeAdapterFactory;
//  The pseudo-adapter explicitly instantiated
//  by inline adapater declarations.
import jburg.burg.inode.InlineInodeAdapter;
//  Interface for i-node adapters that need
//  to emit support routines into generated source.
import jburg.burg.inode.InodeAuxiliarySupport;

// Utility routines.
import static jburg.burg.JBurgUtilities.*;

//  Token types from ANTLR.
import jburg.parser.JBurgTokenTypes;

//  Version file, generated by build.
import jburg.version.JBurgVersion;

import java.io.PrintStream;
import java.io.PrintWriter;

import java.lang.reflect.Modifier;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;


@SuppressWarnings("nls")
public class JBurgGenerator implements JBurgTokenTypes
{
    /**
     *  The JBurg specification's rules are categorized as:
     *  <ul>
     *  <li> Pattern  (e.g., integer = PLUS(integer, integer) )
     *  <li> Simple Transformational   (e.g., registerOperand  = integer)
     *  <li> Complex Transformational  (e.g., string = integer { code to convert integer to string} )
     *  </ul>
     *
     *  Simple transformational rules allow a subgoal to satisfy
     *  other subgoals without additional processing; complex
     *  transformational rules allow one subgoal to feed additional
     *  processing that can satisfy other subgoals (at added cost).
     *
     *  Syntactically, a simple transformational rule is distinguished 
	 *  by its lack of a block of code.
	 *  Simple transformational rules are also known as "chain rules"
	 *  in simpler BURGs that don't support complex transformational
	 *  rules.  This longer name was adopted to highlight that difference,
	 *  but a simple transformational rule is, in fact, a chain rule
	 *  by a different name.
     */

	/**
     *   The table of all transformation rules; keyed
     *   by the rules' antecedent state, e.g., integer
	 *   in the rule number = integer).
     */
    Map<String, Vector<JBurgRule>> transformationRules = new HashMap<String, Vector<JBurgRule>>();

	/**
	 *  The table of all pattern rules, keyed
	 *  by the top-level operator of the pattern,
	 *  e.g., PLUS in the pattern integer = PLUS(integer, integer).
	 */
    Map<String, Vector<JBurgRule>> patternRules = new HashMap<String, Vector<JBurgRule>>();

    /**
     *  Closure sets, keyed by their goal state.
     */
    Multimap<String, ClosureRecord> closureSets = new Multimap<String, ClosureRecord>();

    /**
     *  Action code fragments.
     */
    ArrayList<JBurgReduceAction> reduceActions = new ArrayList<JBurgReduceAction>();

    /**
     *  Cost function fragments.
     *  Note that cost functions may also be embedded
     *  in the inline code blocks in a specification.
     */
    ArrayList<AST> costFunctions = new ArrayList<AST>();

    /**  The names of any interfaces that the generated BURM implements.  */
    Vector<String> interfaceNames = new Vector<String>();
    
    /** blocks of code to be added into the class verbatim */
    Vector<String> inclassCode = new Vector<String>();

    /**  Header code, copied as-is into the reducer. */
    String headerBlock = null;

    /**
     *  The return types for specific states.
     */
    Map<String, String> returnTypeTable = new HashMap<String, String>();

    /**
     *  The default return type of the reducer functions.
     *  If this is defaulted to null, the generated reducer will return nodes of the iNodeClass.
     */
    String defaultReturnType = null;

    private final static String STRICT_RETURN_TYPE = "-Strict state types-";

    /**
     *  Table of properties to be added to the BURM.
     *  Each one is a name/type pair; the BURM gets
     *  a private member and get/set methods.
     */
    Map<String, Object> burmProperties = new HashMap<String, Object>();

    /**
     *  Simple transformations delegate to their antecedent reduction,
     *  so all transformations to a given nonterminal state can share the
     *  same rule.
     */
    Map<String, JBurgRule> simpleTransformationRules = new HashMap<String,JBurgRule>();
    
    /** 
     * If the pattern-matcher generator fails, dump its annotation tree here.
     * Note: this is only enabled (or useful) when debugging JBurg's own BURM. 
     */
    String patternMatcherDumpFile = null;

    /**  
     *  Caller's logging interface.  If defaulted to null, informational and
     *  error messages go to System.out and System.err respectively.
     */
    Logger logger = null;
    
    /**
     * Name for the language to emit code in (default is assumed to be Java)
     */
    String emitLanguageName = null;
    
    /** Code emitter to use (selected using the language name) */
	EmitLang codeEmitter = null;

    /**
     * Inline declarations of I-node logic.
     */
    AST inlineGetOperator;
    AST inlineGetChildCount;
    AST inlineGetChild;

	/**  Cumulative error count. */
	int errCount = 0;

    /**  Prologue snippets mapped to the corresponding rule number. */
    Map<Integer,AST> prologueBlocks = new TreeMap<Integer,AST>();

    /**
     * The master list of rules by equivalence class.
     */
    RulesByOperatorAndArity annotationsByEquivalenceClass = new RulesByOperatorAndArity(this);

    /**
     * operator mapped to node type. This map is populated by JBurg.NodeType
     * directives.
     * <p>
     * For example, an operator named IdentifierID would be associated with
     * {@code IIdentifierNode*} in this map if the input contained
     * {@code JBurg.NodeType IdentifierID = IIdentifierNode*;
     */
    final Map<String, String> opcodeNodeTypes = new HashMap<String, String>();
    
    /**
     *  Manifest constants in the JBurg specification.
     */
    Map<String,Integer> manifestConstants = new HashMap<String,Integer>();
    
    /**
     *  Manifest constant for method declarations.
     */
    final private static Class<?>[] throwsNothing = null;

    /**
     *  Manifest constant for method declarations.
     */
    final private static Class<?>[] throwsException = new Class<?>[] { Exception.class };

    /**
     *  Manifest constant for method declarations.
     */
    final private static FormalParameter[] noFormalParameters = null;

    /**
     *  Manifest constant for an unfeasible rule.
     */
    final private static String NO_FEASIBLE_RULE = "-1";

    /**
     *  Manifest constant for an uninitialized cost.
     */
    final private static String UNINITIALIZED = "-1";

    /**
     *  NamedPattern holds a named pattern, and keeps a table of the reductions that refer to it.
     */
    class NamedPattern
    {
        String patternName;
        AST pattern = null;
        Vector<AST> reductions = new Vector<AST>();

        NamedPattern(String name)
        {
            this.patternName = name;
        }
    }

    /**
     *  A PatternMap keeps the map of pattern names to reductions.
     */
    @SuppressWarnings("serial")
    class PatternMap extends  TreeMap<String,NamedPattern>
    {
        NamedPattern getPattern(String key)
        {
            if ( !super.containsKey(key) )
                put(key, new NamedPattern(key));
            return super.get(key);
        }

        void addPattern(String key, AST pattern)
        {
            NamedPattern p = getPattern(key);
            p.pattern = pattern;
        }

        void addReduction(String key, AST reduction)
        {
            NamedPattern p = getPattern(key);
            p.reductions.add(reduction);
        }
    }

    /**
     * Patterns declared separately from the
     * reduction(s) that use them, e.g.,
     * Pattern callMethod = CALL(expression method, expression parameters*);
     * expression = Pattern callMethod: cost1
     * void_expression = Pattern callMethod: cost2
     */
    PatternMap namedPatterns = new  PatternMap();

    /**
     * The active configuration.
     * TODO: Use a BURM to build the configuration
     * and semantic analysis data structures from the AST,
     * pass the semantic analyzer and the configuration to
     * the generator.
     */
    public Configuration config;

    /**
     *  @param root - the root of the AST generated by parsing the .jburg specification.
     *  @param log - a sink for diagnostics.
     */
    public JBurgGenerator(AST root, Logger log, Options options) throws Exception
    {
        this.logger = log;
        this.config = new Configuration(options);

        this.config.goalStateNames = new HashSet<String>();

        //  Walk over the children of the root, each of which 
		//  is a self-contained syntactical construct, and
        //  perform the appropriate action for each.
        for (AST currentNode = root; currentNode != null;
                currentNode = currentNode.getNextSibling()) 
		{
            switch (currentNode.getType()) 
			{
            case COST_FUNCTION:
                this.costFunctions.add(currentNode);
                break;

            case HEADER_DECLARATION:

				if ( null == this.headerBlock ) {

					this.headerBlock = getCodeBlock(currentNode);
				} else {
                    throw new IllegalArgumentException("The class header may only be specified once.");
				}
                break;
                
            case INCLASS_DECLARATION: {
            		this.inclassCode.add( stripBrackets(getCodeBlock(currentNode)) );
            	}
				break;

            case INODE_ADAPTER_DECLARATION:

                if (config.iNodeAdapterClass == null) {

					config.iNodeAdapterClass = getIdentifierText(currentNode.getFirstChild());
				} else {
                    throw new IllegalArgumentException("INodeAdapter may only be specified once.");
				}

				break;

            case INODE_TYPE_DECLARATION:

                if (config.iNodeClass == null) {

                    config.iNodeClass = getIdentifierText(currentNode.getFirstChild());
				} else {
                    throw new IllegalArgumentException("INodeType may only be specified once.");
				}
                break;
                
            case LANGUAGE_DECLARATION:

            	if ( null == this.emitLanguageName ) {

            		this.emitLanguageName = currentNode.getFirstChild().getText();
				} else {
            		throw new IllegalArgumentException("Language may only be specified once.");
				}
            	break;

            case EXTENDS_CLASS_SPECIFICATION:
                config.baseClassName = getIdentifierText( currentNode.getFirstChild());
                break;

            case IMPLEMENTS_INTERFACE_SPECIFICATION:
                this.interfaceNames.addElement(getIdentifierText( currentNode.getFirstChild()) );
                break;

            case PACKAGE_SPECIFICATION:

                if ( null == config.packageName ) {

					config.packageName = getIdentifierText(currentNode.getFirstChild());
				} else {
            		throw new IllegalArgumentException("package may only be specified once.");
				}
                break;

            case PROPERTY_SPECIFICATION: {
					String propertyType = getIdentifierText(currentNode.getFirstChild());
					String propertyName = currentNode.getFirstChild().getNextSibling().getText();
					this.burmProperties.put(propertyName, propertyType);
				}
                break;

            case RETURN_DECLARATION:

                if (this.defaultReturnType == null) {
                    this.defaultReturnType = getIdentifierText(currentNode.getFirstChild());
                    config.returnTypes.add(this.defaultReturnType);
                } else if (this.defaultReturnType == STRICT_RETURN_TYPE) {
                    throw new IllegalArgumentException( "When StrictReturnType is specified, ReturnType must specify a state name");
                } else {
                    throw new IllegalArgumentException( "ReturnType may only be specified once.");
                }
                break;

            case STRICT_TYPE:
                if (this.defaultReturnType == null || this.defaultReturnType == STRICT_RETURN_TYPE) {
                    this.defaultReturnType = STRICT_RETURN_TYPE;
                } else {
                    throw new IllegalArgumentException( "ReturnType declaration with default (empty) state conflicts with StrictReturnType declaration.");
                }
                break;

            case PATTERN_RULE:
                addPatternRule(currentNode);
                break;

            case SIMPLE_TRANSFORMATION_RULE:
                addSimpleTransformationRule(currentNode);
                break;

            case TRANSFORMATION_RULE:
                addComplexTransformationRule(currentNode);
                break;

            case TYPED_RETURN_DECLARATION: {

                    String stateName = currentNode.getFirstChild().getText();
                    String returnType = getIdentifierText(currentNode.getFirstChild().getNextSibling());

                    //  Put the return declaration in the table, but only once per state.
                    Object typeCollision = this.returnTypeTable.put(stateName, returnType);
                    if ( null != typeCollision )
                    {
                        throw new IllegalArgumentException(
                            "A state may only specify one ReturnType."
                        );
                    }
                    config.returnTypes.add(returnType);
                }
                break;

            case PATTERN_DECLARATION: {

                    String pattern_name = currentNode.getFirstChild().getText();
                    namedPatterns.addPattern(pattern_name, currentNode);
                }
                break;

            case REDUCTION_DECLARATION: {

                    String pattern_name = currentNode.getFirstChild().getNextSibling().getText();
                    namedPatterns.addReduction(pattern_name, currentNode);
                }
                break;

            case DEFAULT_ERROR_HANDLER:
                config.defaultErrorHandler = getCodeBlock(currentNode);
                break;

            case NODE_TYPE: {

                final String operatorID = currentNode.getFirstChild().getText();
                assert !operatorID.isEmpty() : "Parser should never create empty operator!";
                final String nodeType = currentNode.getFirstChild().getNextSibling().getText();               
                assert !nodeType.isEmpty() : "Parser should never create empty node type!";
                
                if (this.opcodeNodeTypes.put(operatorID, nodeType) != null) {
                    throw new IllegalArgumentException(String.format("Duplicate node type declaration for '%s'", operatorID));
                }
                break;
            }
            case OPCODE_TYPE:
                config.opcodeType = currentNode.getFirstChild().getText();
                break;

            case NON_TERMINAL_ENUM:
                config.ntType = currentNode.getFirstChild().getText();
                break;

            case MANIFEST_CONSTANT:
                manifestConstants.put(currentNode.getFirstChild().getText(), Integer.parseInt(currentNode.getFirstChild().getNextSibling().getText()));
                break;

            case VOLATILE_COST:

                for ( AST volatileCost = currentNode.getFirstChild().getNextSibling(); volatileCost != null; volatileCost = volatileCost.getNextSibling() ) {
                    config.volatileCostFunctions.add(volatileCost.getText());
                }
                break;

            case OPTION_SETTING: {

            	String optionName = currentNode.getFirstChild().getText();
            	String optionValue = currentNode.getFirstChild().getNextSibling().getText();
            	
            	if ( optionName.equalsIgnoreCase("ignoreNullInode")) {
            		config.generateNullTolerantLabeller = optionValue.equalsIgnoreCase("true");
            	}
            	break;
            }

            case GET_CHILD:
                this.inlineGetChild = currentNode;
                break;
            case GET_OPERATOR:
                this.inlineGetOperator = currentNode;
                break;
            case GET_COUNT:
                this.inlineGetChildCount = currentNode;
                break;

            case ALLOCATOR:
                config.allocator = currentNode.getFirstChild().getText();
                break;

            case ANNOTATION_EXTENDS:
                config.annotationBaseClassName = currentNode.getFirstChild().getText();
                break;

            case ANNOTATION_DECLARATION: {

                AST getDeclaration = currentNode.getFirstChild();
                AST setDeclaration = getDeclaration.getNextSibling();

                config.annotationAccessor = new AnnotationAccessor(
                    getDeclaration.getFirstChild().getText(),
                    getDeclaration.getFirstChild().getNextSibling().getText(),
                    setDeclaration.getFirstChild().getText(),
                    setDeclaration.getFirstChild().getNextSibling().getText(),
                    setDeclaration.getFirstChild().getNextSibling().getNextSibling().getText(),
                    setDeclaration.getFirstChild().getNextSibling().getNextSibling().getNextSibling().getText()
                );
                break;
            }

            case INIT_STATIC_ANNOTATION:
                config.initStaticAnnotation = currentNode.getFirstChild().getText();
                break;

            default:
                throw new IllegalArgumentException("Unknown specification AST type " +
            											String.valueOf(currentNode.getType()));
            }
        }

        //  Set the language emitter.
        codeEmitter = JBurgEmitterFactory.getEmitter(emitLanguageName, getLogger());

        if ( codeEmitter != null ) {
            codeEmitter.setConfiguration(config);
            codeEmitter.setINodeType(config.iNodeClass);
            codeEmitter.setAllocator(config.allocator);
            codeEmitter.setAnnotationAccessor(config.annotationAccessor);
            codeEmitter.setOpcodeType(config.opcodeType);
            codeEmitter.setDefaultAttribute("annotationClass", null);
		} else {
			throw new IllegalStateException("Unknown language specified: \""+ emitLanguageName +"\"");
        }

        if (inlineGetChild != null || inlineGetOperator != null || inlineGetChildCount != null) {

            if (inlineGetChild == null || inlineGetOperator == null || inlineGetChildCount == null) {
                throw new IllegalStateException("@getChild, @getOperator, and @getChildCount must all be specified.");
            }

            config.iNodeAdapter = new InlineInodeAdapter(
                inlineGetOperator.getFirstChild().getNextSibling().getText(),
                inlineGetOperator.getFirstChild().getText(),
                inlineGetChild.getFirstChild().getNextSibling().getNextSibling().getText(),
                inlineGetChild.getFirstChild().getText(),
                inlineGetChild.getFirstChild().getNextSibling().getText(),
                inlineGetChildCount.getFirstChild().getNextSibling().getText(),
                inlineGetChildCount.getFirstChild().getText()
            );
        } else if ( config.iNodeClass != null ) {

            // If an i-node adapter was specified by class name, instantiate an instance.
            // Otherwise, get an adapter from the factory's known instances.
			if ( config.iNodeAdapterClass != null ) {
				try {
					config.iNodeAdapter = (InodeAdapter)Class.forName(config.iNodeAdapterClass).newInstance();
				} catch ( Exception ex ) {
					this.logger.exception("loading i-node adapter", ex);
                    this.logger.error("Unable to instantiate i-node adapter %s", config.iNodeAdapterClass);
				}
			} else {
				config.iNodeAdapter = InodeAdapterFactory.getAdapter(config.iNodeClass, logger);
			}
			
			codeEmitter.setINodeType(config.iNodeClass);

			if ( config.iNodeAdapter != null ) {
				logger.info("Using i-node adapter %s\n", config.iNodeAdapter.getClass().getName() );
			} else {
				getLogger().warning("Using default i-node adapter, no adapter matches %s\n", config.iNodeClass );
				config.iNodeAdapter = new jburg.burg.inode.DefaultAdapter();
			}
		} else {
			logger.error("You must specify the i-node type.\n");
		}

        if ( logger.getErrorCount() > 0 )
            return;

		codeEmitter.setInodeAdapter(config.iNodeAdapter);
        codeEmitter.setNtType(config.ntType);

        //  Default return type is the same as the INode class.
        if (this.defaultReturnType == null)
		{
            this.defaultReturnType = config.iNodeClass;
		}

        //  Expand pattern/reduction pairs into pattern rules.
        for ( NamedPattern np: namedPatterns.values() )
        {
            if ( np.pattern != null && np.reductions.size() > 0 )
            {
                AST named_pattern = np.pattern.getFirstChild().getNextSibling().getFirstChild();

                for ( AST reduction: np.reductions )
                {    
                    //  Splice the pattern into the reduction AST.
                
                    AST nt_state = reduction.getFirstChild();
                    AST pattern_name = nt_state.getNextSibling();
                    AST cost_decl = pattern_name.getNextSibling();
                    
                    //  Create a new holder for the pattern
                    //  so the original AST isn't mutated.
                    AST pattern_holder = new antlr.CommonAST();
                    pattern_holder.setFirstChild(named_pattern);
                    nt_state.setNextSibling(pattern_holder);
                    pattern_holder.setNextSibling(cost_decl);
    
                    //  Give the composite AST the appropriate type
                    //  for its pattern.
                    reduction.setType(PATTERN_RULE);
    
                    addPatternRule(reduction);
                }
            }
            else if ( np.pattern != null )
            {
                getLogger().warning("pattern %s has no reduction - ignored.\n", np.patternName );
            }
            else if ( np.reductions.size() > 0 )
            {
                throw new IllegalStateException("Reduction " + np.patternName + " has no associated pattern.");
            }
        }

        //  Add target-specific logic to the simple transformations' rules.
        for ( JBurgRule rule: this.simpleTransformationRules.values() ) {
            JBurgReduceAction action = addAction(rule, rule.getGoalState());
            action.setAntecedentState(rule.getAntecedentState());
        }
    }
    
    /**
     *  Add a reduce action to the action list.
	 *  Actions are keyed by number in the generated BURM.
     *  @param action - the rule that uses this action.
     *  @param goalState - the nonterminal state that represents
     *  the result of this reduction.
     */
    private JBurgReduceAction addAction(JBurgRule rule, String goalState)
    {
        JBurgReduceAction newAction = new JBurgReduceAction(rule, goalState, this);
        rule.setReduceAction(newAction);
        this.reduceActions.add(newAction);

        //  Annotate this action with its state index:
        //  the 0th index is used as the default action for
        //  simple transformation rules, so use 1-based counting.
        newAction.setIndex(this.reduceActions.size());
        return newAction;
    }

    /**
     *  Analyze a rule's action routine specifications
     *  and extract its prologue reduction, if any.
     *  @param rule - rule.
     *  
     */
    private void extractPrologue(JBurgRule rule)
    {
        AST reduction = null;

        if ( hasASTOfType(rule.m_AST, REDUCTION_ACTION) )
            reduction = getASTByType(rule.m_AST, REDUCTION_ACTION);
        else if ( hasASTOfType(rule.m_AST, EXPLICIT_REDUCTION ) )
            reduction = getASTByType(rule.m_AST, EXPLICIT_REDUCTION);
        else
            return;
        
        if ( hasASTOfType(reduction, PROLOGUE) )
            this.prologueBlocks.put(rule.getReduceAction().index, getASTByType(reduction, PROLOGUE));
    }

    /**
     *  Add a complex transformation rule to its table,
     *  and record the rule's reduction action.
     */
    private void addComplexTransformationRule(AST transform)
        throws Exception
    {
        JBurgRule n = addNamedRule(this.transformationRules, transform);

        //  Prepare the rule's reduce action.
        JBurgReduceAction action = addAction(n, n.getGoalState());
        action.setAntecedentState(n.getAntecedentState());
        extractPrologue(n);

        //  Add the antecedent state by name as an alias action routine "parameter."
        //  The "parameter" is popped off the reduced values stack into a local variable.
        action.addParameter(
            n.getAntecedentState(), 
            n.getAntecedentState(), 
            ParameterDescriptor.ArityType.Fixed
        );
    }

    /**
     *  If this simple transformation is not yet known, add it to its rule table.
     */
    private void addSimpleTransformationRule(AST transform)
    {
        JBurgRule newRule = new JBurgRule(transform, this);

        String key = String.format("%s=%s", newRule.getGoalState(), newRule.getAntecedentState());

        if ( ! this.simpleTransformationRules.containsKey(key) )
        {
            //  Ensure this rule's nonterminal is known.
            this.config.goalStateNames.add(newRule.getGoalState());
            addNamedRule(this.transformationRules, newRule);

            //  Target-specific action logic will be
            //  added once the code emitter is up.
            this.simpleTransformationRules.put(key, newRule);
        }
    }

    /**
     *  Wrap a pattern rule in an I-node, and add it to the pattern rule table.
     */
    private void addPatternRule(AST newRule) throws Exception
    {
        JBurgRule n = addNamedRule(this.patternRules, newRule);
        addAction(n, n.getGoalState());
        extractPrologue(n);
    }

    /**
     *  Wrap a rule in an I-node, and add it to the list of rules
     *  that produce a particular subgoal.
     */
    private JBurgRule addNamedRule(Map<String, Vector<JBurgRule>> ruleTable, AST newAST)
    {
        JBurgRule newRule = new JBurgRule(newAST, this);

        //  Ensure this rule's nonterminal is known.
        this.config.goalStateNames.add( newRule.getGoalState() );
        return addNamedRule(ruleTable, newRule);
    }

    /**
     *  Add a rule to its rule table.
     *  @param ruleTable - the appropriate table for this type of rule.  Keyed by operator.
     *  @param newRule - the rule to add.
     */
    private JBurgRule addNamedRule(Map<String, Vector<JBurgRule>> ruleTable, JBurgRule newRule)
    {
        //  Store the rule by operator.
        String operator = newRule.getOperator();

        Vector<JBurgRule> vRules = ruleTable.get(operator);

        if (vRules == null)
        {
            vRules = new Vector<JBurgRule>();
            ruleTable.put(operator, vRules);
        }

        vRules.add(newRule);

        return newRule;
    }

    /**
     *  Compute the closure set of a rule:  the set of rules that
     *  that can transform this rule's goal to satsify another goal.
	 *  @note computeClosure is public so that it can be applied.
     */
    public void computeClosure(JBurgRule n) throws Exception
    {
		//  Get the list of transformation rules that can use this rule's goal state.
        Vector<JBurgRule> closureCandidates = this.transformationRules.get(n.getGoalState());

        if (closureCandidates != null) {

            for (JBurgRule nPrime:closureCandidates ) {

                ClosureRecord newClosure = new ClosureRecord(nPrime, this);

                if (!this.closureSets.getSet(n.getGoalState()).contains(newClosure)) {
                    this.closureSets.addToSet(n.getGoalState(), newClosure);
                }

            }
        }
    }

    /**
     *  Scan all the rules and compute their closure sets.
     */
    private void computeClosureSets() throws Exception
    {
        for (Vector<JBurgRule> patternRulesByNonterminal: this.patternRules.values() ) {
            applyToAll( this, patternRulesByNonterminal, "computeClosure", JBurgRule.class);
        }

        for (Vector<JBurgRule> transformations : this.transformationRules.values() ) {
            applyToAll( this, transformations, "computeClosure", JBurgRule.class);
        }
    }

    public void semanticAnalysis()
    throws Exception
    {
        // Add pattern rules' parameterized subtrees and named (terminal)
        // subtrees as pseudo-parameters to their action routines.
        for (Vector<JBurgRule> patternRulesByNonterminal: this.patternRules.values()) {

            for (JBurgRule rule: patternRulesByNonterminal) {

                for (JBurgPatternMatcher subgoal: rule.patternMatcher.getParameterizedSubtrees()) {

                    rule.getReduceAction().addParameter(
                            subgoal.getParameterName(), 
                            subgoal.getSubgoal(), 
                            subgoal.isNary()? ParameterDescriptor.ArityType.Variable: ParameterDescriptor.ArityType.Fixed
                            );
                }

                //  Add the named subtrees as a convenience.
                for ( JBurgPatternMatcher named_terminal: rule.patternMatcher.getNamedSubtrees()) {

                    rule.getReduceAction().addNamedSubtree(
                            named_terminal.generateReduceTimePath(codeEmitter, config.reducerNodeName, config.iNodeAdapter), 
                            named_terminal.getParameterName()
                            );
                }

                //  If the pattern matches an operator, send that operator
                //  to the rule so it can be matched in content-access snippets.
                if ( rule.patternMatcher.matchesOperator() )
                    rule.getReduceAction().setOperator(rule.patternMatcher.getOperator());
            }
        }
        
        for (Vector<JBurgRule> patternRules: this.patternRules.values()) {
            annotationsByEquivalenceClass.addAll(patternRules);
        }

        computeClosureSets();
        annotationsByEquivalenceClass.analyze();
    }

    /**
     *  Emit the BURG specification's resultant BURM to an output stream.
     */
    public void emit(String className, PrintStream output)
    throws Exception
    {
        codeEmitter.setClassName(className);
        codeEmitter.setDebugMode(config.options.debug);

        emitHeader(output);
        codeEmitter.emitInclass(this.inclassCode, output);
        emitNTConstants(this.config.goalStateNames, output);

        if ( config.iNodeAdapter instanceof InodeAuxiliarySupport ) {
            ((InodeAuxiliarySupport)config.iNodeAdapter).emitAuxiliarySupport(codeEmitter, output);
        }

        emitLabelFunction(output);
        emitActions(output);
        emitCostFunctions(output);
        emitAnnotations(output);
        emitSubgoalLookupTables(output);
        emitTrailer(output);
    }

    private void emitTrailer(PrintStream output)
    {
        //  Translate prologue blocks.
        Map<Integer, Object> translatedPrologues = new HashMap<Integer, Object>();

        for ( Integer key: this.prologueBlocks.keySet() )
        {
            AST prologue = this.prologueBlocks.get(key);

            if ( hasASTOfType(prologue, BLOCK) )
                translatedPrologues.put(key, getCodeBlock(prologue));
            else if ( hasASTOfType(prologue, PROCEDURE_CALL) )
                translatedPrologues.put(key, emitExpression(getASTByType(prologue, PROCEDURE_CALL)) + ";");
            else
                throw new IllegalStateException("Prologue block with no inline code or callback");
        }
        
        codeEmitter.emitTrailer(
            this.config.goalStateNames,
            this.burmProperties,
            config.defaultErrorHandler,
            translatedPrologues,
            output
        );
    }

    /**
     * Emit static lookup tables.
     */
    private void emitSubgoalLookupTables(PrintStream output)
    {
        Map<Integer, Vector<JBurgPatternMatcher>> rules_by_action = new HashMap<Integer,Vector<JBurgPatternMatcher>>();
        int max_action = 0;

        // Populate the rules_by_action table and find the maximum action number used by a pattern rule.
        for (Vector<JBurgRule> patternRulesByNonterminal: this.patternRules.values()) {

            for (JBurgRule p: patternRulesByNonterminal) {

                int action_number = p.getReduceAction().getIndex();
                max_action = Math.max(max_action, action_number);
                
                if ( p.patternMatcher.isNary() ) {

                    rules_by_action.put(action_number,new Vector<JBurgPatternMatcher>());
                    rules_by_action.get(action_number).add(p.patternMatcher);

                } else if (!p.patternMatcher.getParameterizedSubtrees().isEmpty() ) {

                    rules_by_action.put(action_number,p.patternMatcher.getParameterizedSubtrees());
                }
            }
        }

        //  Find the maximum action number in a pattern rule or chain rule.
        for ( Vector<JBurgRule> transformations:  this.transformationRules.values() )
            for ( JBurgRule t: transformations )
                max_action = Math.max(max_action, t.getReduceAction().getIndex());
        
        codeEmitter.emitSubgoalLookupTables(max_action, rules_by_action, output);

        //  Generate manifest constant declarations.
        for ( Map.Entry<String,Integer> constants : this.manifestConstants.entrySet() )
            output.println(
                getTemplate(
                    "constant",
                    "type", "int",
                    "name", constants.getKey(),
                    "value", constants.getValue().toString()
                )
            );
    }

    /**
      *  Emit the file/class header information.
      */
    private void emitHeader(PrintStream output)
    {
        output.println(codeEmitter.genComment(String.format(" Generated %s by JBurg version %s ", new java.util.Date(), JBurgVersion.version)));
        output.println();

        if (config.annotationAccessor != null) {
            for (AnnotationSemantics semantics: annotationsByEquivalenceClass.getSingletonAnnotations()) {
                codeEmitter.addSingletonAnnotationClass(semantics.getSpecializedClassName());
            }
        }

        codeEmitter.emitHeader(
            config.packageName,
            this.headerBlock,
            config.baseClassName,
            this.interfaceNames,
            output
        );
    }

	/**
	 *  @return the return type for a specific state.
	 */
	public String getReturnType(String stateName)
	{
		if (returnTypeTable.containsKey(stateName)) {
            return returnTypeTable.get(stateName).toString();
        } else if (this.defaultReturnType != STRICT_RETURN_TYPE) {
			return defaultReturnType;
        } else {
            throw new IllegalArgumentException(String.format("No return type for state %s",stateName));
        }
	}
	
    /**
     * @param cost a call to a cost function.
     * @return true iff the cost function is not listed as volatile.
     */
    boolean isStableCostFunction(String cost)
    {
        for ( String volatileCost: config.volatileCostFunctions )
            if ( cost.startsWith(volatileCost) )
                return false;

        return true;
    }

    /**
     * Emit code to call the action routines.
     */
	private void emitActions(PrintStream output)
	{
        // Action 0 is hard-coded noop.
		int i = 1;

		//  Print out the individual action routines.
		for (JBurgReduceAction nextAction: reduceActions )
		{
            output.println();
			output.println(codeEmitter.genComment(nextAction.getState()));
			
            //  Compute the type of the i-node.
            String typeOfOperatorINode;
			final String actionOperator = nextAction.getOperator();

			if ( opcodeNodeTypes.containsKey(actionOperator) )
			    typeOfOperatorINode = opcodeNodeTypes.get(actionOperator);
			else
			    typeOfOperatorINode = config.iNodeClass;

            StringTemplate actionRoutine = defineMethod(
				Modifier.PRIVATE,
				getReturnType(nextAction.getState()),
				"action_" + String.valueOf(i++),
				FormalParameter.buildFormals(typeOfOperatorINode, config.reducerNodeName),
				throwsException
			);
				
			//  Replace #goalstate with the name of the action's input node.
			String goalPattern = "#" + nextAction.getState();
			addContents(actionRoutine, nextAction.emit().replaceAll(goalPattern, config.reducerNodeName));

            output.println(actionRoutine);
		}

		//  Emit their common dispatch routine.
        String nodeName = config.annotationAccessor == null? "___node" : config.reducerNodeName;
        FormalParameter[] formals = config.annotationAccessor == null?
			FormalParameter.buildFormals(config.options.annotationInterfaceName, nodeName, "int", "iRule"):
			FormalParameter.buildFormals(config.iNodeClass, nodeName, "int", "iRule");

        StringTemplate dispatchAction =
		defineMethod(
			Modifier.PRIVATE,
			"void",
			"dispatchAction",
			formals,
			throwsException
		);

        if (config.annotationAccessor == null) {
            addLocalVar(
                dispatchAction,
                config.iNodeClass,
                config.reducerNodeName,
                this.codeEmitter.genCallMethod(nodeName, "getNode")
            );
        }

        StringTemplate dispatchSwitch = addSubTemplate(dispatchAction, "switch", "expr", "iRule");

		//  Emit the dispatch case statement.
		for (i = 1; i <= reduceActions.size(); i++)
		{
            JBurgReduceAction action = reduceActions.get(i-1);

            StringTemplate switchCase = addSubTemplate(
                dispatchSwitch,
                "switchCase",
                "label", String.valueOf(i)
            );

            //  If this is a nonterminal-to-nonterminal
            //  transformation, run the antecedent
            //  reduction action.
            if ( action.hasAntecedentState() )
            {
                addExprStatement(
                    switchCase,
                    codeEmitter.genCallMethod(
                        "this",
                        "reduceAntecedent",
                        nodeName, codeEmitter.genGetGoalState(action.getAntecedentState())
                    )
                );
            }

            String operatorName = action.getOperator();
            String nodeTypeForOperator =
                operatorName != null ?
                    opcodeNodeTypes.get(operatorName):
                    null;

            Object nodeParameterString =
                nodeTypeForOperator != null?
                    codeEmitter.genCast(nodeTypeForOperator, config.reducerNodeName):
                    config.reducerNodeName;
            
            addContents(
                switchCase,
                codeEmitter.getTemplate(
                    "pushReducerIntermediate",
                    "stackName", config.reducedValuesName,
                    "valueType", getReturnType(action.getState()),
                    "valueExpr", this.codeEmitter.genCallMethod(
                        "this",
                        "action_" + String.valueOf(i),
                        nodeParameterString
                    )
                )
            );
		}

        StringTemplate defaultCase = codeEmitter.getTemplate("switchDefaultNoFallthrough");
        addExprStatement(defaultCase, codeEmitter.genThrow(codeEmitter.getStringIntConcat("\"Unmatched reduce action \"", "iRule")));

        addContents(dispatchSwitch, defaultCase);

		output.println(dispatchAction);
	}

    /**
     * Emit the state identifiers.
     */
	private void emitNTConstants(Set<String> goal_states, PrintStream output)
	{
        // Don't emit these constants if the nonterminal type
        // was explicitly set.
        if ( ! config.ntType.equals("int") )
            return;

		Iterator<String> keys = goal_states.iterator();

		int nthConstant = 0;

		for (String rawState: goal_states) {
			nthConstant++;

            output.println(
                getTemplate(
                    "constant",
                    "type",     "int",
                    "name",     codeEmitter.genGetGoalState(rawState),
                    "value",    String.valueOf(nthConstant)
                )
			);
		}
	
        // Emit the number of states.
        output.println(
            getTemplate(
                "constant",
                "type", "int",
                "name", "nStates",
                "value", String.valueOf(nthConstant)
            )
		);
	}

    /**
     * Emit cost functions.
     */
	public void emitCostFunctions(PrintStream output) 
	{
		FormalParameter[] costParms = FormalParameter.buildFormals(config.iNodeClass, config.reducerNodeName);

		for (AST currentCostFunction: costFunctions) {

			String functionName = currentCostFunction.getFirstChild().getText();

			StringTemplate costFunction = defineMethod(Modifier.PRIVATE, "int", functionName, costParms, throwsNothing );
			addContents(costFunction, getCodeBlock(currentCostFunction));
            output.println(costFunction);
		}
	}

    /**
     * Emit the label(ast) function.
     */
	public void emitLabelFunction(PrintStream output)
	{
        Object setAnnotation = config.annotationAccessor != null?
                codeEmitter.genCallMethod(
                    config.initialParamName,
                    "setAnnotation", 
                    codeEmitter.genCast(config.annotationAccessor.setParameterType, "result")
                ):
                null;

		output.println(getTemplate(
            "labelFunction",
            "getArity",         new GetArity(config.initialParamName),
            "getNthChild",      new GetNthChild(config.initialParamName, "i"),
            "setAnnotation",    setAnnotation
        ));
	}

    /**
     *  Emit the subclasses of JBurgAnnotation that encode data for specific pattern matches,
     *  and getJBurgAnnotation(inode), the routine that assigns an annotation to each inode.
     *  @param output - the destination output stream.
     */
    void emitAnnotations(PrintStream output)
    {
        Set<String> allOperators = annotationsByEquivalenceClass.getOperators();

        //  Emit an annotation object for each equivalence class of rules.
        for ( String operator: allOperators )
            for ( AnnotationSemantics currentAnnotation : annotationsByEquivalenceClass.getAnnotationSemantics(operator))
                emitAnnotation(output, operator, currentAnnotation);

        //  Emit getJBurgAnnotation
        StringTemplate getJBurgAnnotation = defineMethod(
            Modifier.PUBLIC,
            config.options.annotationInterfaceName,
            "getJBurgAnnotation",
            FormalParameter.buildFormals(config.iNodeClass, "node"),
            throwsNothing
        );

        // A code fragment that fetches the node's actual arity.
        Object actualArity = new GetArity("node");
        Object actualOpcode = new GetOperator("node");

        StringTemplate switchOnNode = addSubTemplate(
            getJBurgAnnotation,
            "switch",
            "expr", actualOpcode
        );

        for ( String operator: allOperators ) {

            StringTemplate opCase = addSubTemplate(switchOnNode, "switchCase", "label", operator);

            for ( AnnotationSemantics annotationSemantics : annotationsByEquivalenceClass.getAnnotationSemantics(operator)) {

                Object annotation;
                
                if (config.annotationAccessor != null && annotationSemantics.canBeSingleton()) {
                    annotation = getTemplate(
                        "singletonInstance",
                        "singletonClass", annotationSemantics.getSpecializedClassName()
                    );
                } else {
                    annotation = getTemplate(
                        "newObject",
                        "type", annotationSemantics.getSpecializedClassName(),
                        "parameters", "node"
                    );
                }

                int arity = annotationSemantics.getMinimumArity();

                StringTemplate ifStmt = addSubTemplate(
                    opCase,
                    "ifThen",
                    "condition",
                        annotationSemantics.hasFixedArity()?
                            getTemplate("equals", "lhs", actualArity, "rhs", arity):
                            getTemplate("greaterThanOrEquals", "lhs", actualArity, "rhs", arity),
                    "contents", getTemplate("returnStmt", "value", annotation)
                );
            }
        }

        // Fall through and return the placeholder annotation.
        StringTemplate switchDefault = addSubTemplate(switchOnNode, "switchDefault");

        addSubTemplate(
            getJBurgAnnotation,
            "returnStmt",
            "value", codeEmitter.genNewObject( "PlaceholderAnnotation", "node", actualArity)
        );

        output.println(getJBurgAnnotation);
    }

    /**
     *  Emit an annotation subclass.
     *  @param output - the output stream.
     *  @param currentRules - the set of rules that are this annotation's
     *    domain.  The rules all have the same operator, but their arity
     *    may differ if some of them are n-ary.
     */
    void emitAnnotation(PrintStream output, String operator, AnnotationSemantics semantics)
    {
        List<JBurgRule> currentRules = semantics.getRules();
        int nominalArity = semantics.getMinimumArity();

        // Closure cost graph.
        ClosureGraph closureCosts = semantics.getClosureGraph();

        // Pattern-matching rules by nonterminal.
        AnnotationSemantics.ProductionMap patternMatches = semantics.getPatternMatches();
 
        //  Pattern-matching rules and closures by nonterminal.
        AnnotationSemantics.ProductionMap productions = semantics.getAllProductions();

        //  Cached subtree costs.
        Map<String, String> cachedCosts = new HashMap<String, String>();

        //  Does the annotation have fixed arity?
        boolean fixedArity = semantics.hasFixedArity();

        // Find goal states that need to have their costs cached.
        for ( JBurgRule rule: currentRules) {

            if ( rule.patternMatcher.getNominalArity() > 0 || rule.patternMatcher.hasNaryness() ) {
                cachedCosts.put(rule.getGoalState(), String.format("cachedCostFor_%s", rule.getGoalState()));
            }
        }

        //  Emitting these variable declarations mutates the 
        //  pattern matchers, so they can only be emitted once.
        //  Capture the results so we can write it more than once.
        Map<JBurgPatternMatcher,String> factored_variables = emitFactoredPathVariables(semantics.getCommonSubtrees());

        /*
         * Begin code-gen of the class.
         */
        output.println();
        String annotationClassName = semantics.getSpecializedClassName();
        StringTemplate annotationClass = getTemplate(
            "innerClass",
            "className", annotationClassName,
            "baseClassName", "JBurgSpecializedAnnotation"
        );

        //  Emit caches for any costs that require a function call;
        //  the BURM's contract says these functions are only called once.
        Set<String> emittedCosts = new HashSet<String>();

        for ( List<ClosureRecord> closures: closureCosts.values() )
            for ( ClosureRecord closure: closures )
                if ( closure.costComputedViaFunction() && emittedCosts.add(closure.getCachedCost()) )
                    addCachedCost(annotationClass, closure.getCachedCost(), closure.getCost("m_node")); 

        for ( JBurgRule rule: currentRules ) {

            if ( rule.needsExplicitCostCheck() && rule.isStableCostFunction() )
                addGetCostForRule(annotationClass, rule, factored_variables);

            if ( rule.costComputedViaFunction() && rule.isStableCostFunction() && emittedCosts.add(rule.getCachedCost()) )
                addCachedCost(annotationClass, rule.getCachedCost(), rule.getCost("m_node")); 
        }

        this.codeEmitter.setDefaultAttribute("annotationClass", annotationClassName);
        
        //  Emit a field for each child.
        for ( int fieldIdx = 0; fieldIdx < nominalArity; fieldIdx++ ) {

            addContents(
                annotationClass,
                codeEmitter.genInstanceField(
                    Modifier.PRIVATE,
                    config.options.annotationInterfaceName,
                    String.format("subtree%d", fieldIdx),
                    codeEmitter.genNullPointer()
                )
            );
        }

        for ( String cachedCostVar: cachedCosts.values() ) {

            addContents(
                annotationClass,
                codeEmitter.genInstanceField( Modifier.PRIVATE, "int", cachedCostVar, UNINITIALIZED)
            );
        }

        if ( !fixedArity ) {

            addContents(
                annotationClass,
                codeEmitter.genInstanceField( 
                    Modifier.PRIVATE,
                    codeEmitter.genNaryContainerType(config.options.annotationInterfaceName),
                    "narySubtrees",
                    codeEmitter.defineContainer(config.options.annotationInterfaceName)
                )
            );
        }

        // Emit the constructor.
        StringTemplate constructor = codeEmitter.getConstructorBody(
            codeEmitter.declareMethod(
                Modifier.PUBLIC,
                "",
                annotationClassName,
                FormalParameter.buildFormals(config.iNodeClass, "node"),
                throwsNothing
            ),
            "JBurgSpecializedAnnotation",
            "node"
        );
        addContents(annotationClass, constructor);

        // getPatternMatchCost(nonterminal)
        if ( patternMatches.keySet().size() > 0 ) {

            StringTemplate getPatternMatchCost = addMethod(
                annotationClass,
                Modifier.PRIVATE,
                "int",
                "getPatternMatchCost",
                FormalParameter.buildFormals(config.ntType, "goalState"),
                throwsNothing
            );

            addVariableDecl(getPatternMatchCost, "int", "result", codeEmitter.genMaxIntValue());

            StringTemplate switchOnGoal = addSubTemplate(getPatternMatchCost, "switch", "expr", "goalState");

            for ( String nonterminal: patternMatches.keySet() ) {

                List<JBurgProduction> currentPatterns = patternMatches.get(nonterminal);

                StringTemplate switchCase = getTemplate("switchCase", "label", getUndecoratedNonterminal(nonterminal));
                addContents(switchOnGoal, switchCase);

                // TODO: If there's only one alternative, then just call getCost()
                // to use the cached cost if it's present.
                addAssignment(switchCase, "result", getCostForProduction(currentPatterns.get(0), productions));

                for ( int i = 1; i < currentPatterns.size(); i++ )
                    addAssignment(switchCase, "result", genMinimum("result", getCostForProduction(currentPatterns.get(i), productions)));
            }
            addReturnValue(getPatternMatchCost, "result");
        }

        // getClosureCost(nonterminal)
        ArrayList<String> closureCaches = new ArrayList<String>();

        if ( closureCosts.keySet().size() > 0 ) {

            StringTemplate getClosureCost = addMethod(
                annotationClass,
                Modifier.PRIVATE,
                "int",
                "getClosureCost",
                FormalParameter.buildFormals(config.ntType, "goalState"),
                throwsNothing
            );

            addVariableDecl(getClosureCost, "int", "result", codeEmitter.genMaxIntValue());

            StringTemplate switchOnGoal = getTemplate("switch", "expr", "goalState");
            addContents(getClosureCost, switchOnGoal);
            
            for ( String nonterminal : closureCosts.keySet() ) {

                StringTemplate switchCase = getTemplate("switchCase", "label", getUndecoratedNonterminal(nonterminal));
                addContents(switchOnGoal, switchCase);

                Set<String> doneNts = new HashSet<String>();
                List<String> closureComputations = new ArrayList<String>();

                for ( ClosureRecord closure: closureCosts.get(nonterminal) )
                    closureComputations.addAll(getAntecedentCosts(closure, doneNts, closureCosts, patternMatches));

                if ( doneNts.contains(nonterminal) )
                    logger.error(String.format("cyclical closure from %s to %s", nonterminal, nonterminal));

                // Don't emit pattern match costs for the final level;
                // they're redundant with the computation in getCost().
                closureComputations.add(getClosureCostComputation(nonterminal, closureCosts, patternMatches, false));

                boolean cacheClosure = closureComputations.size() > config.closureCacheThreshold;
                String closureCacheVar = String.format("cachedClosure_%x", System.identityHashCode(closureComputations));

                StringTemplate closureContainer = switchCase;

                if ( cacheClosure ) {

                    closureCaches.add(closureCacheVar);
                    closureContainer = getTemplate(
                        "ifThen",
                        "condition", getTemplate("equals", "lhs", closureCacheVar, "rhs", UNINITIALIZED)
                    );
                    addContents(switchCase, closureContainer);
                }

                for ( String s: closureComputations )
                    addContents(closureContainer, s);

                if ( cacheClosure ) {

                    addAssignment(closureContainer, closureCacheVar, String.format("cost_%s", nonterminal));
                    addAssignment(switchCase, "result", closureCacheVar);

                } else {
                    addAssignment(switchCase, "result", String.format("cost_%s", nonterminal));
                }
            }

            addReturnValue(getClosureCost, "result");
        }

        for ( String closureCacheVar: closureCaches ) {

            addContents(annotationClass, codeEmitter.genInstanceField(Modifier.PRIVATE, "int", closureCacheVar, UNINITIALIZED));
        }

        // getCost(nonterminal)
        StringTemplate getCost = addMethod(
            annotationClass,
            Modifier.PUBLIC,
            "int",
            "getCost",
            FormalParameter.buildFormals(config.ntType, "goalState"),
            throwsNothing
        );

        addVariableDecl(getCost, "int", "result", codeEmitter.genMaxIntValue());

        StringTemplate switchOnGoal = getTemplate("switch", "expr", "goalState");
        addContents(getCost, switchOnGoal);

        for ( String nonterminal: semantics.getAllGoalStates() ) {

            StringTemplate switchCase = addSubTemplate(
                switchOnGoal, 
                "switchCase",
                "label", getUndecoratedNonterminal(nonterminal)
            );

            Object cost = semantics.findOptimalCost(nonterminal);

            StringTemplate callGetPatternMatchCost = getTemplate(
                "callMethod",
                "nameElements", "getPatternMatchCost",
                "params", getNonterminal(nonterminal)
            );

            StringTemplate callGetClosureCost = getTemplate(
                "callMethod",
                "nameElements", "getClosureCost",
                "params", getNonterminal(nonterminal)
            );

            if (cost != null) {
                // Cost is known at compiler-compile time and
                // its value is in the cost variable; carry on
                // and emit it.
            } else if ( closureCosts.containsKey(nonterminal) && patternMatches.containsKey(nonterminal) ) {
                cost = genMinimum(callGetPatternMatchCost, callGetClosureCost);
            } else if ( patternMatches.containsKey(nonterminal) ) {
                cost = callGetPatternMatchCost;
            } else if ( closureCosts.containsKey(nonterminal) ) {
                cost = callGetClosureCost;
            } else {
                throw new IllegalStateException("Internal error: No closure or pattern cost for " + nonterminal);
            }

            if ( cachedCosts.containsKey(nonterminal) ) {

                String cachedCostVar = cachedCosts.get(nonterminal);

                // Put the cost into the cache if it's not already done.
                StringTemplate checkCache = addSubTemplate(
                    switchCase,
                    "ifThen",
                    "condition", getTemplate("equals", "lhs", cachedCostVar, "rhs", UNINITIALIZED)
                );

                addAssignment(checkCache, cachedCostVar, cost);
                addAssignment(switchCase, "result", cachedCostVar);

            } else {
                addAssignment(switchCase, "result", cost);
            }
        }

        addReturnValue(getCost, "result");

        /*
         *  ** Emit getRule()  **
         */
        StringTemplate getRule = addMethod(
            annotationClass,
            Modifier.PUBLIC,
            "int",
            "getRule",
            FormalParameter.buildFormals(config.ntType, "goalState"),
            throwsNothing
        );

        addVariableDecl(getRule, "int", "rule", NO_FEASIBLE_RULE);
        switchOnGoal = addSubTemplate(
            getRule,
            "switch",
            "expr", "goalState"
        );

        boolean allRulesConstant = true;

        for ( Map.Entry<String, List<JBurgProduction>> productionsByNonterminal: productions.entrySet() ) {

            String nonterminal = productionsByNonterminal.getKey();

            StringTemplate switchCase = addSubTemplate(
                switchOnGoal,
                "switchCase",
                "label", getUndecoratedNonterminal(nonterminal)
            );

            /*
             * Try to resolve the optimal production at compiler-compile time.
             */
            JBurgProduction optimalProduction = semantics.findOptimalProduction(nonterminal);

            if ( optimalProduction != null ) {
                addAssignment(switchCase, "rule", Integer.toString(optimalProduction.getReduceAction().getIndex()));
            } else {

                allRulesConstant = false;

                /*
                 * Emit the analogous compile-time computation.
                 */
                List<JBurgProduction> currentProductions = productionsByNonterminal.getValue();

                int nProductions = currentProductions.size();

                //  Emit this declaration at its first use.
                boolean currentCostDeclared = false;

                // Cache the best cost so far if necessary.
                Object bestKnownCost;

                if ( nProductions > 1 ) {
                    addVariableDecl(switchCase, "int", "bestCost", codeEmitter.genMaxIntValue());
                    bestKnownCost = "bestCost";
                } else {
                    bestKnownCost = codeEmitter.genMaxIntValue();
                }

                for ( int i = 0; i < nProductions; i++ ) {

                    boolean costIsVariable = true;
                    Object  currentProductionCost;

                    //  Extract required information from the production:
                    //  what is its cost, and is it constant?
                    JBurgProduction production = currentProductions.get(i);

                    if ( production.computesConstantCost(productions) ) {

                        int constantCost = production.getConstantCost(productions);
                        costIsVariable = constantCost == Integer.MAX_VALUE;
                        currentProductionCost = Integer.toString(constantCost);

                    } else {
                        currentProductionCost = getCostForProduction(production, productions);
                    }

                    //  Generate the necessary tests and assignments.

                    //  If the first production's cost is constant
                    //  (and feasible, which has been checked and
                    //  incorporated into costIsVariable), then 
                    //  testing it against bestCost is a tautology.
                    boolean needComparison = (costIsVariable) || i > 0;

                    StringTemplate costContainer = switchCase;

                    if ( needComparison ) {

                        //  If the cost uses a computation, put it in a temp.
                        if ( costIsVariable ) {

                            if ( currentCostDeclared ) {

                                addAssignment(switchCase, "currentCost", currentProductionCost);
                                currentProductionCost = "currentCost";

                            } else if ( nProductions > 1 && costIsVariable ) {

                                addVariableDecl(switchCase, "int", "currentCost", currentProductionCost);
                                currentCostDeclared = true;
                                currentProductionCost = "currentCost";
                            }
                            // else fall through using the cost in-line for the comparison.
                        }

                        costContainer = addSubTemplate(
                            costContainer,
                            "ifThen",
                            "condition", codeEmitter.genCmpLess(bestKnownCost.toString(), currentProductionCost)
                        );
                    }

                    //  Track the new best cost if there's another choice to be evaluated.
                    if ( i + 1 < currentProductions.size() )
                        addAssignment(costContainer, bestKnownCost, currentProductionCost);

                    addAssignment(costContainer, "rule", production.getReduceAction().getIndex());
                }
            }
        }

        addReturnValue(getRule, "rule");

        /*
         *  ** Emit getArity()  **
         */
        StringTemplate getArity = addMethod(
            annotationClass, 
            Modifier.PUBLIC,
            "int",
            "getArity",
            noFormalParameters,
            throwsNothing
        );

        if ( fixedArity ) {

            addReturnValue(getArity, Integer.toString(nominalArity));
        } else {

            StringTemplate narySize = getTemplate("narySubtreeSize", "stem", "narySubtrees");

            if ( nominalArity != 0 ) {

                addReturnValue(getArity, codeEmitter.genCast("int", getTemplate("add", "lhs", nominalArity, "rhs", narySize)));
            } else {

                addReturnValue(getArity, narySize);
            }
        }


        /*
         *  **  Emit overrides for getNthChild() and addChild() if necessary  **
         */
        if ( nominalArity > 0 || ! fixedArity ) {

            //  getNthChild
            StringTemplate getNthChild = addMethod(
                annotationClass,
                Modifier.PUBLIC,
                config.options.annotationInterfaceName,
                "getNthChild",
                FormalParameter.buildFormals("int", "index"),
                throwsNothing
            );

            addVariableDecl(getNthChild, codeEmitter.getAnnotationType(), "result", getTemplate("nullPointer"));
            StringTemplate switchOnIndex = addSubTemplate(getNthChild, "switch", "expr", "index");

            for ( int i = 0; i < nominalArity; i++ ) {

                StringTemplate switchCase = addSubTemplate(switchOnIndex, "switchCase", "label", new Integer(i));
                addAssignment(switchCase, "result", String.format("subtree%d", i));
            }

            if ( ! fixedArity ) {

                StringTemplate switchDefault = addSubTemplate(switchOnIndex, "switchDefault");
                if ( nominalArity == 0 ) {

                    addSubTemplate(switchDefault,
                        "assign",
                        "lvar", "result",
                        "rvalue", getTemplate("narySubtreeGet", "stem", "narySubtrees", "index", "index")
                    );
                } else {

                    addSubTemplate(switchDefault,
                        "assign",
                        "lvar", "result",
                        "rvalue", getTemplate(
                            "narySubtreeGet",
                            "stem", "narySubtrees",
                            "index", getTemplate("subtract", "lhs", "index", "rhs", new Integer(nominalArity))
                        )
                    );
                }
            } else {

                StringTemplate switchDefault = addSubTemplate(switchOnIndex, "switchDefaultNoFallthrough");
                addThrow(switchDefault, codeEmitter.getStringIntConcat("\"Invalid index \"", "index"));
            }

            addReturnValue(getNthChild, "result");

            //  addChild
            StringTemplate addChild = addMethod(
                annotationClass,
                Modifier.PUBLIC,
                "void",
                "addChild",
                FormalParameter.buildFormals(config.options.annotationInterfaceName, "child"),
                throwsNothing
            );

            // We're going to compose a sequence
            // of operations, each extending the
            // previous operation.
            StringTemplate previousOp = addChild;

            if ( nominalArity > 0 ) {

                for ( int i = 0; i < nominalArity; i++ ) {

                    Object currentChild = String.format("subtree%d", i);
                    StringTemplate isNull = getTemplate("isNull", "expr", currentChild);

                    if ( i == 0 ) {

                        StringTemplate ifThen = getTemplate("ifThen", "condition", isNull);
                        addContents(previousOp, ifThen);
                        previousOp = ifThen;
                    } else {

                        StringTemplate elseif = getTemplate("ifElseArm", "condition", isNull);
                        previousOp.setAttribute("elseArm", elseif);
                        previousOp = elseif;
                    }
                    addAssignment(previousOp, currentChild, "child");
                }

                StringTemplate finalElse = getTemplate("ifElseArm");
                previousOp.setAttribute("elseArm", finalElse);
                previousOp = finalElse;
            }

            if ( ! fixedArity ) {
                addExprStatement(previousOp, codeEmitter.getAddChild());
            } else {
                addThrow(previousOp, "\"too many children\"");
            }
        }

        /*
         * Emit overrides for getOperator() and getSelfDescription().
         */
        StringTemplate getOperator = addMethod(
            annotationClass,
            Modifier.PUBLIC,
            config.opcodeType,
            "getOperator",
            noFormalParameters,
            throwsNothing
        );

        addReturnValue(getOperator, operator);

        StringTemplate getSelfDescription = addMethod(
            annotationClass,
            Modifier.PUBLIC,
            codeEmitter.getStringClassName(),
            "getSelfDescription",
            noFormalParameters,
            throwsNothing
        );

        // FIXME: Need a genStringConstant routine.
        addReturnValue(getSelfDescription, "\"" + annotationClassName + "\"");

        //  Write out the compressed annotation's class declaration.
        output.println(annotationClass);

        // Reset the class name to default.
        this.codeEmitter.setDefaultAttribute("annotationClass", null);
    }

    /**
     *  @return the expression to use for a production's cost;
     *    this may be an arithmetic expression or a call
     *    to an implementation method, depending on
     *    the production's complexity.
     */
    Object getCostForProduction(JBurgProduction production, AnnotationSemantics.ProductionMap productions)
    {
        if ( production instanceof JBurgRule )
        {
            JBurgRule rule = (JBurgRule) production;
            if ( rule.needsExplicitCostCheck() )
            {
                if ( rule.isStableCostFunction() )
                    return this.codeEmitter.genCallMethod(null, getCostingFunctionForRule(rule), "goalState");
                else
                    return rule.getCost("getNode()");
            }
            else
            {
                return getSumOfRuleCosts(rule);
            }
        }
        else
        {
            return ((ClosureRecord)production).getCostComputation(productions);
        }
    }

    /**
     *  Emit a rule's cost function.
     *  @param output - the current output stream.
     *  @param rule - the rule to emit.
     *  @param factored_variables - the list of pattern matchers it's worth factoring.
     */
    void addGetCostForRule(StringTemplate container, JBurgRule rule, Map<JBurgPatternMatcher,String> factored_variables )
    {
        assert(rule.needsExplicitCostCheck());

        StringTemplate method = addMethod(
            container,
            Modifier.PRIVATE,
            "int",
            getCostingFunctionForRule(rule),
            FormalParameter.buildFormals(config.ntType, "goalState"),
            throwsNothing
        );

        for ( String var_decl: factored_variables.values() )
            if ( rule.patternMatcher.usesFactoredVariable(var_decl) )
                addContents(method, var_decl);

        Object patternMatch = rule.patternMatcher.generatePatternRecognizer(
                codeEmitter,
                "this"
            );

        // The pattern match may be null if it's trival.
        StringTemplate matcher;

        if ( patternMatch != null ) {

            matcher = addSubTemplate(
                method,
                "ifThen",
                "condition", patternMatch
            );

            StringTemplate failedMatch = getTemplate("ifElseArm");
            addReturnValue(failedMatch, codeEmitter.genMaxIntValue());
            matcher.setAttribute("elseArm", failedMatch);

        } else {
            matcher = method;
        }

        addReturnValue(matcher, getSumOfRuleCosts(rule));
    }

    /**
     *  @return a unique identifier for the method that computes
     *    a rule's cost (note: this is not the rule's cost function).
     */
    String getCostingFunctionForRule(JBurgRule rule)
    {
        return String.format("getCostFor%s", rule.getUniqueId());
    }

    /**
     *  Emit the cache field and accessor function for
     *  the cached result of a cost function call.
     */
    void addCachedCost(StringTemplate container, String functionName, String payload)
    {
        //  Strip () characters.
        functionName = functionName.substring(0, functionName.length() -2);

        String varName = String.format("cachedCostFunctionResult_%h", functionName);

        addContents(container, codeEmitter.genInstanceField( Modifier.PRIVATE, "int", varName, UNINITIALIZED));

        StringTemplate method = addMethod(
            container,
            Modifier.PRIVATE,
            "int",
            functionName,
            noFormalParameters,
            throwsNothing
        );

        StringTemplate testInit = addSubTemplate(
            method,
            "ifThen",
            "condition", codeEmitter.genCmpEquality(varName, UNINITIALIZED, true)
        );
        addAssignment(testInit, varName, payload);
        addReturnValue(method, varName);
    }

    /**
     *  Add up all of a rule's cost factors.
     *  @param rule - the rule of interest.
     *  @return an overflow-safe addition of the
     *    rule's cost and the costs of its subtrees.
     */
    Object getSumOfRuleCosts(JBurgRule rule)
    {
        Object subtreeCost = null;

        for ( JBurgPatternMatcher subgoal: rule.patternMatcher.getParameterizedSubtrees() ) {
            Object subgoalCost = subgoal.generateCost(codeEmitter, "this");

            if ( subgoalCost != null )
                subtreeCost = codeEmitter.genOverflowSafeAdd(subtreeCost, subgoalCost);
        }

        if ( subtreeCost != null ) {
            return codeEmitter.genOverflowSafeAdd(rule.getCachedCost("getNode()"), subtreeCost);
        } else {
            return rule.getCachedCost();
        }
    }

    /**
     *  Emit the factored path variables into a map,
     *  and mutate the affected pattern matchers
     *  to refer to the factored variable.
     *  @param commonSubtrees - the map of common subtrees to their pattern matchers.
     */
    Map<JBurgPatternMatcher,String> emitFactoredPathVariables(AnnotationSemantics.CommonSubtreeMap commonSubtrees)
    {
        Map<JBurgPatternMatcher,String> result = new TreeMap<JBurgPatternMatcher, String>();

        int varNum = 0;
        for ( Map.Entry<JBurgPatternMatcher, List<JBurgPatternMatcher>> factored: commonSubtrees.entrySet() )
        {
            String varName = String.format("factoredPath_%d", varNum++);

            result.put(factored.getKey(), codeEmitter.genLocalVar(config.options.annotationInterfaceName, varName, factored.getKey().generateFactoredReference(codeEmitter)).toString());

            for ( JBurgPatternMatcher matcher: factored.getValue() )
                matcher.factoredPath = varName;
        }
    
        return result;
    }

    /**
     *  @return the current Logger implementation;
     *    constructs a Logger that emits messages
     *    to stdout/stderr.
     */
    Logger getLogger()
    {
        if ( null == this.logger )
            this.logger = new Logger(true, true, true);
        return this.logger;
    }

    StringTemplate defineMethod(int modifiers, Object returnType, Object name, FormalParameter[] formalParameters, Class<?>[] exceptions )
    {
        return getTemplate(
            "method",
            "decl", codeEmitter.declareMethod (
                modifiers,
                returnType,
                name,
                formalParameters,
                exceptions
            )
        );
    }

    /**
     * Add a local variable to a container template.
     * @param container     the containing template.
     * @param varType       the variable's type.
     * @param varName       the variable's name.
     * @param initializer   the variable's initializer, or null.
     */
    void addLocalVar(StringTemplate container, Object varType, Object varName, Object initializer)
    {
        addContents(container, codeEmitter.genLocalVar(varType, varName, initializer));
    }

    /**
     *  Convenience method wraps codeEmitter.genGetGoalState.
     */
    Object getNonterminal(String raw_nt)
    {
        return codeEmitter.genGetGoalState(raw_nt);
    }

    /**
     *  Convenience method wraps codeEmitter.genGetUndecoratedGoalState.
     */
    Object getUndecoratedNonterminal(String raw_nt)
    {
        return codeEmitter.genGetUndecoratedGoalState(raw_nt);
    }

    /**
     *  @return the input string with its outer
     *    layer of {} brackets stripped off.
     */
    public static String stripBrackets(String src)
    {
        int startchar = src.indexOf('{') + 1;
        int lentoend = src.lastIndexOf('}');
        return src.substring( startchar, lentoend-startchar );
    
    }

    /**
     *  Generate the calling sequence for the label() method.
     */
    Object genCallLabel(Object indexTerm)
    {
        return this.codeEmitter.genCallMethod(
            "this",
            "label",
            codeEmitter.genCast( 
                config.iNodeClass, 
                new GetNthChild(config.initialParamName, indexTerm)
            )
        );
    }

    /**
     * Generate code to check for a minumum of two values.
     * @param lhs the left-hand expression.
     * @param rhs the right-hand expression.
     * @return platform-specific code to get the minimum of these values.
     */
    Object genMinimum(Object lhs, Object rhs)
    {
        if ( lhs.equals(rhs) && config.volatileCostFunctions.size() == 0 )
            return lhs.toString();
        else
            return getTemplate("minimumOf", "e1", lhs, "e2", rhs);
    }

    /**
     * Translate a JBurg platform-neutral expression
     * into platform-specific code.
     */
    Object emitExpression(AST expr)
    {
        ExpressionParser parser = new ExpressionParser();
        parser.setCodeEmitter(this.codeEmitter);

        try {
            parser.burm(expr);
        }
        catch ( Exception burmProblem ) {

            logger.exception(String.format("translating %s", expr), burmProblem);
        }

        return parser.getResult();
    }

    /**
     * Get the cost of a closure as a "term" of a closure cost function.
     * @param nonterminal the goal nonterminal.
     * @param closureCosts the current annotation's graph of closure costs.
     * @param patternMatches the current annotation's pattern matches.
     * @param emitPatternMatch if set, emit a pattern match if the nonterminal
     * has any pattern matches; true when emitting antecedent terms, false
     * when emitting the final term, when the computation would be redundant
     * with the computation in getCost().
     * @return the closure's cost, expressed as an initialization of a cost term.
     */
    String getClosureCostComputation(String nonterminal, ClosureGraph closureCosts, AnnotationSemantics.ProductionMap patternMatches, boolean emitPatternMatch)
    {
        Object minCost;
        String patternMatchCost = this.codeEmitter.genCallMethod("this", "getPatternMatchCost", getNonterminal(nonterminal)).toString();

        //  Determine the minimum cost.
        if ( closureCosts.containsKey(nonterminal) ) {

            List<ClosureRecord> possibleClosures = closureCosts.getSet(nonterminal);

            minCost = getClosureCost(possibleClosures.get(0), closureCosts, patternMatches);

            for ( int i = 1; i < possibleClosures.size(); i++ ) {
                minCost = genMinimum(minCost, getClosureCost(possibleClosures.get(i), closureCosts, patternMatches));
            }

            if ( patternMatches.containsKey(nonterminal) && emitPatternMatch ) {
                minCost = genMinimum(minCost, patternMatchCost);
            }

        } else {
            minCost = patternMatchCost;
        }

        return getTemplate(
            "declareLocalVariable",
            "type", "int",
            "name", String.format("cost_%s", nonterminal), 
            "initializer", minCost
        ).toString();
    }

    /**
     * Get the cost of a closure with its antecedent "term."
     * @param closure the closure of interest.
     * @param closureCosts the current annotation's graph of closure costs.
     * @param patternMatches the current annotation's pattern matches.
     * @return the closure's cost as an expression usable within the annotation class' instance methods.
     */
    String getClosureCost(ClosureRecord closure, ClosureGraph closureCosts, AnnotationSemantics.ProductionMap patternMatches)
    {
        return closure.getCostComputation("getNode()", "cost_" + getNonTrivialAntecedent(closure.getAntecedentState(), closureCosts, patternMatches));
    }

    /**
     * Get all the antecedent costs for a closure.
     * @param closure the closure of interest.
     * @param doneNts antecedents already recorded; mutated to record
     * the current closure, if it hasn't already been emitted.
     * @param closureCosts the current annotation's graph of closure costs.
     * @param patternMatches the current annotation's pattern matches.
     * @return a list of all the antecedent "terms" in the closure cost.
     */
    List<String> getAntecedentCosts(ClosureRecord closure, Set<String> doneNts, ClosureGraph closureCosts, AnnotationSemantics.ProductionMap patternMatches)
    {
        List<String> result = new ArrayList<String>();

        // Look past any trivial antecedents; if foo = bar is the only antecedent
        // reduction, and it has zero cost, and bar itself has an antecedent, then
        // we're interested in the value of bar.
        // TODO: Also elide the corresponding reduction.
        String antecedent = getNonTrivialAntecedent(closure.getAntecedentState(), closureCosts, patternMatches); 

        if ( doneNts.add(antecedent) )
        {
            if ( closureCosts.containsKey(antecedent) )
                for ( ClosureRecord antecedentClosure: closureCosts.get(antecedent) )
                    result.addAll(getAntecedentCosts(antecedentClosure, doneNts, closureCosts, patternMatches));

            result.add(getClosureCostComputation(antecedent, closureCosts, patternMatches, true));
        }

        return result;
    }

    /**
     * Look through any trivial antecedent states; a trivial
     * antecedent has a single, zero-cost closure and no pattern match.
     * @param antecedent the nonterminal state of interest.
     * @param closureCosts the current annotation's graph of closure costs.
     * @param patternMatches the current annotation's pattern matches.
     * @return the first non-trivial antecedent found.
     */
    String getNonTrivialAntecedent(String antecedent, ClosureGraph closureGraph, AnnotationSemantics.ProductionMap patternMatches)
    {
        // If this antecedent state has its own antecedent:
        if (closureGraph.containsKey(antecedent) && !patternMatches.containsKey(antecedent))
        {
            List<ClosureRecord> closures = closureGraph.get(antecedent);
            if ( closures.size() == 1 && closures.get(0).costIsZero() ) {
                // One closure with zero cost: trivial, look through it.
                return getNonTrivialAntecedent(closures.get(0).getAntecedentState(), closureGraph, patternMatches);
            }
        }

        // This is a non-trival closure.
        return antecedent;
    }

    /**
     * Select a template by name, with optional attributes.
     * @param name the template's name.
     * @param attrValue pairs of attrName, attrValue.
     */
    private StringTemplate getTemplate(String name, Object ... attrValue)
    {
        return this.codeEmitter.getTemplate(name, attrValue);
    }

    private StringTemplate addSubTemplate(StringTemplate container, String name, Object ... attrValue)
    {
        StringTemplate contents = getTemplate(name, attrValue);
        addContents(container, contents);
        return contents;
    }

    /**
     * Add a variable declaration to a container's template.
     * @param container the container's template.
     * @param type the variable's type.
     * @param name the variable's name.
     * @param initialValue the variable's initial value, or null.
     */
    private void addVariableDecl(StringTemplate container, Object type, Object name, Object initialValue)
    {
        addFieldOrVariableDecl(container, "declareLocalVariable", type, name, initialValue);
    }

    private void addFieldOrVariableDecl(StringTemplate container, String template,  Object type, Object name, Object initialValue)
    {
        addContents(
            container,
            getTemplate(
                template,
                "type", type,
                "name", name,
                "initializer", initialValue
            )
        );
    }

    /**
     * Add an assignment statement to a container template.
     * @param method the method's template.
     * @param lvalue the receiving lvalue.
     * @param rvalue the value to assign.
     */
    private void addAssignment(StringTemplate method, Object lvalue, Object rvalue)
    {
        addContents(method, getTemplate( "assign", "lvar", lvalue, "rvalue", rvalue));
    }

    /**
     * Add contents to a container template.
     * @param container  the container.
     * @param contents the contents.
     */
    private void addContents(StringTemplate container, Object contents)
    {
        container.setAttribute("contents", contents);
    }

    /**
     * Add a return statement to a container template.
     * @param container the containing template.
     * @param value the value to return.
     */
    private void addReturnValue(StringTemplate container, Object value)
    {
        addContents(container, getTemplate( "returnStmt", "value", value));
    }

    /**
     * Add an expression statement to a container template.
     * @param container the containing template.
     * @param expr the expression to add as a statement-level construct.
     */
    private void addExprStatement(StringTemplate container, Object expr)
    {
        addContents(container, getTemplate("statement", "expr", expr));
    }

    /**
     * Add a throw statement to a container template.
     * @param container the containing template.
     * @param diagnostic an expression that generates a diagnostic.
     */
    private void addThrow(StringTemplate container, Object diagnostic)
    {
        addExprStatement(container, getTemplate("throwDiagnostic", "diagnostic", diagnostic));
    }

    private StringTemplate addMethod(StringTemplate container, int modifiers, Object returnClass, Object name, FormalParameter[] formals, Class[] exceptions)
    {
        StringTemplate result = defineMethod(modifiers, returnClass, name, formals, exceptions);
        addContents(container, result);
        return result;
    }

    /**
     * @return this generator's code emitter.
     */
    public EmitLang getCodeEmitter()
    {
        return this.codeEmitter;
    }
}
